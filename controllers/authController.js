const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');
const User = require('../models/User');

function generateAccessToken(user) {
    return jwt.sign(user, process.env.ACCESS_TOKEN_SECRET, { expiresIn: '15m' });
}

function generateRefreshToken(user) {
    return jwt.sign(user, process.env.REFRESH_TOKEN_SECRET, { expiresIn: '7d' });
}

async function registerUser(userData) {
    if (userData.password !== userData.password2) {
        throw new Error ("Passwords do not match");
    }

    const newUser = new User({
        ...userData,
        role: 'user'
    });

    try {
        await newUser.save();
    }
    catch (err) {
        if (err.code === 11000) {
            throw new Error ("Username already taken");
        }
        else {
            throw new Error (`There was an error creating the user: ${err.message}`);
        }
    }
}

async function loginUser(req, res, user) {
    const payload = { 
        "sub": user._id,
        "username": user.username,
        "role": user.role,
        "auth_method": "password"
    };
    const accessToken = generateAccessToken(payload);
    const refreshToken = generateRefreshToken(payload);

    res.cookie('accessToken', accessToken, {
        httpOnly: true,
        secure: true,
        sameSite: 'None',
        maxAge: 15 * 60 * 1000,
        path: "/"
    });

    res.cookie('refreshToken', refreshToken, {
        httpOnly: true,
        secure: true,
        sameSite: 'None',
        maxAge: 7 * 24 * 60 * 60 * 1000,
        path: "/"
    });
}

const MAX_NUM_HISTORY = 8;
async function checkUser(userData) {
    const user = await User.findOne({ username: userData.username });
    if (!user) {
        throw new Error(`Unable to find user: ${userData.username}`);
    }

    const valid = await bcrypt.compare(userData.password, user.password);
    if (!valid) {
        throw new Error(`Incorrect password for user: ${userData.username}`);
    }

    if (user.loginHistory.length > MAX_NUM_HISTORY) {
        user.loginHistory = user.loginHistory.slice(0, 8);
    }

    user.loginHistory.unshift({
        dateTime: new Date().toString(),
        userAgent: userData.userAgent
    });

    try {
        await User.updateOne(
            { username: user.username },
            { $set: { loginHistory: user.loginHistory } }
        );
    }
    catch (err) {
        throw new Error(`There was an error verifying the user: ${err.message}`);
    }

    return user;
}

function logoutUser(req, res) {
    res.clearCookie('accessToken', {
        httpOnly: true,
        secure: true,
        sameSite: 'None'
    });

    res.clearCookie('refreshToken', {
        httpOnly: true,
        secure: true,
        sameSite: 'None'
    });

    res.redirect("/");
}

async function refreshAccessToken(req, res) {
    const refreshToken = req.cookies.refreshToken;

    if (!refreshToken) {
        return res.status(401).json({ message: "No refresh token provided" });
    }

    try {
        const user = jwt.verify(refreshToken, process.env.REFRESH_TOKEN_SECRET);
        if (user) {
            const payload = {
                sub: user.sub,
                username: user.username,
                role: user.role,
                auth_method: "refresh_token"
            };

            const newAccessToken = generateAccessToken(payload);
            res.cookie('accessToken', newAccessToken, {
                httpOnly: true,
                secure: true,
                sameSite: 'None',
                maxAge: 15 * 60 * 1000,
                path: "/"
            });

            return res.status(200).json({ message: "Access token successfully generated by refresh token"});
        }
    }
    catch (err) {
        return res.status(403).json({ message: "Invalid or expired refresh token" });
    }
}

module.exports = { registerUser, checkUser, loginUser, logoutUser, refreshAccessToken };
